/** 
 	@page chapter_unittesting Unit Testing

	@author Jamoma, Timothy Place & Nathan Wolek

	@section chapter_unittesting_ide Running Tests in IDE

	@section chapter_unittesting_ruby Running Tests in Ruby

	The Ruby implementation provides another easy method to perform unit tests.  
	In the [Jamoma/Core/DSP/Tests](https://github.com/jamoma/JamomaCore/tree/master/DSP/Tests/unit) folder, there is a simple example (<tt>gain.test.rb</tt>) which looks like this:

	@include ../../Core/DSP/Tests/unit/gain.test.rb

	The <tt>require</tt> statement loads the Jamoma Foundation.  
	The following line instantiates the #TTGain class.  
	Once we have an instance, we send it the test message to run the test.  
	You can run this ruby script in the terminal by typing <tt>'ruby gain.test.rb'</tt> and it will quickly return the results to you.

	@section chapter_unittesting_writingtests Writing Tests in C++

	Any object inheriting from #TTDataObjectBase will inherit a 'test' message.  
	#TTDataObjectBase defines a virtual default test method.  
	This test will be run unless you specify your own test method.  
	The default test method simply reports a failure because you haven't written a custom test.  
	To define your test method, you can use the following prototype (which is the same as for any message with arguments in Jamoma):

	@snippet ../../Core/Foundation/library/includes/TTDataObjectBase.h doxygenChapter60_virtualMethod

	You can then implement a test with code such as the block that follows.
	A test may make 'assertions' that certain conditions be true.
	If any of these conditions are not true, then they are logged to the console and test will fail.

	@snippet ../../Core/DSP/extensions/EffectsLib/tests/TTGain.test.cpp doxygenChapter60_testExample

*/
